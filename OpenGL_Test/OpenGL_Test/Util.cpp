#include "Util.h"
#include "Level.h"

extern LEVEL Level;

bool Simulating = false;
bool Paused = false;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

bool ShowStress()
{
	return true;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

float RoundToNearestGridMarker(float loc)
{
	int num = (int)loc;
	if( num % GridSpacing < GridSpacing/2)
	{
		return num - num % GridSpacing;
	}
	else
	{
		return num + GridSpacing - num % GridSpacing;
	}
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

bool IsSimulating()
{
	return Simulating;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void SetSimulating(bool Sim)
{
	if( Simulating != Sim )
	{
		if( Sim )
		{
			fprintf(stderr, "\n\n\nStarting Simulation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\n" );
			Level.StartSimulation();
		}
		else
		{
			Level.EndSimulation();
		}
	}
	Simulating = Sim;
}

bool IsPaused()
{
	return Paused;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

void SetPaused(bool Pause)
{
	Paused = Pause;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

float maxf(float x, float y)
{
	if(x > y )
	{
		return x;
	}

	return y;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

float minf(float x, float y)
{
	if(x < y )
	{
		return x;
	}

	return y;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

bool Vector2D::Equals(Vector2D* Point)
{
	return Point->x == x && Point->y == y;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

Vector2D& Vector2D::operator - (const Vector2D& rhs)
{
	Vector2D temp(this->x, this->y);
	temp.x -= rhs.x;
	temp.y -= rhs.y;
	return temp;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

Vector2D& Vector2D::operator+(const Vector2D& rhs)
{
	Vector2D temp(this->x, this->y);
	temp.x += rhs.x;
	temp.y += rhs.y;
	return temp;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

float Vector2D::Dot(const Vector2D& rhs)
{
	return this->x*rhs.x + this->y*rhs.y;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

float Vector2D::Cross(const Vector2D& rhs)
{
	return (this->y * rhs.x) - (this->x * rhs.y);
}